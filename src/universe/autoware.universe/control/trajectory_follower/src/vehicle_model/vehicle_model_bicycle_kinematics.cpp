// Copyright 2018-2021 The Autoware Foundation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

#include "trajectory_follower/vehicle_model/vehicle_model_bicycle_kinematics.hpp"

#include <cmath>

namespace autoware
{
namespace motion
{
namespace control
{
namespace trajectory_follower
{
KinematicsBicycleModel::KinematicsBicycleModel(
  const double wheelbase, const double steer_lim, const double steer_tau)
: VehicleModelInterface(/* dim_x */ 3, /* dim_u */ 1, /* dim_y */ 2, wheelbase)
{
  m_steer_lim = steer_lim;
  m_steer_tau = steer_tau;
}

void KinematicsBicycleModel::calculateDiscreteMatrix(
  Eigen::MatrixXd & a_d, Eigen::MatrixXd & b_d, Eigen::MatrixXd & c_d, Eigen::MatrixXd & w_d,
  const double dt)
{
  // auto sign = [](double x) { return (x > 0.0) - (x < 0.0); };

  // /* Linearize delta around delta_r (reference delta) */
  // double delta_r = atan(m_wheelbase * m_curvature);
  // if (std::abs(delta_r) >= m_steer_lim) {
  //   delta_r = m_steer_lim * static_cast<double>(sign(delta_r));
  // }
  // double cos_delta_r_squared_inv = 1 / (cos(delta_r) * cos(delta_r));
  // double velocity = m_velocity;
  // if (std::abs(m_velocity) < 1e-04) {
  //   velocity = 1e-04 * (m_velocity >= 0 ? 1 : -1);
  // }

  // // HH_231102 -- Autoware MPC
  // a_d << 0.0, velocity, 0.0, 
  //        0.0, 0.0, velocity / m_wheelbase * cos_delta_r_squared_inv, 
  //        0.0, 0.0, -1.0 / m_steer_tau;

  // b_d << 0.0, 0.0, 1.0 / m_steer_tau;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.0,
  //   -velocity * m_curvature +
  //     velocity / m_wheelbase * (tan(delta_r) - delta_r * cos_delta_r_squared_inv),
  //   0.0;

///////////////////////////////////////////////////////////////////////////////////////////////

  //EDMDc HH_231121
  // a_d << 1.000, -0.3188, -0.2319,
  //         0.0, 0.9961, -0.0052,
  //         0.0, -0.0087, 1.0102;

  // b_d << 0.4095,
  //       0.0032,
  //       -0.0074;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.0,
  //       0.0,
  //       0.0; 
  //EDMDc good driving HJ_231214
  // a_d << 1.000, -0.2155, -0.1910,
  //         0.0, 0.9961, -0.0052,
  //         0.0, -0.0087, 1.0102;

  // b_d << 0.4995,
  //       0.0202,
  //       -0.0154;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.0,
  //       0.0,
  //       0.0;

  // EDMDc 
  // a_d << 1.000, -0.003, 0.026,
  //      0.0, 0.999, -0.090,
  //      0.0, 0.0, 0.989;

  // b_d << -0.093,
  //       0.084,
  //       0.010;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.0,
  //       0.0,
  //       0.0; 
  
  // EDMDc v cycle
  // a_d << 1.000, 0.0004, 0.0590,
  //       0.0, 0.999, -0.021,
  //       0.0, 0.0, 0.989;

  // b_d << -0.033,
  //         0.0119,
  //         0.0108;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.0,
  //       0.0,
  //       0.0; 

  // EDMDc matrix (create using deviation)
  // a_d << 1.000, 0.0165, -0.0024,
  //       0.0, 0.9954, -0.0016,
  //       0.0, 0.0, 0.9278;

  // b_d <<  0.0039,
  //         0.0,
  //         0.0722;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.0,
  //       0.0,
  //       0.0; 


  // DMDc HH_231121
  // a_d << 1.0, 0.011, -0.015,
  //      -0.00009, 0.757, 0.090,
  //      0.00003, 0.087, 0.965;
  // b_d << -0.028,
  //        0.262,
  //        -0.093;
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.0,
  //        0.0,
  //        0.0; 

///////////////////////////////////////////////////////////////////////////////////////////////


  //HH_231015_2
  // Koopman Neural Network | traning data_loss_0.03 (w/ yaw error) 
  a_d << -0.19835101, -0.3375339, -0.12927282, 
        0.24552305, 0.11873358, -0.13700576,
        0.1340872, 0.24476781, 0.10393731;

  b_d << -0.49352682,
          0.36990735,
          -0.00790359;

  c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  w_d << 0.0, 0.0, 0.0;


///////////////////////////////////////////////////////////////////////////////////////////////

  // HH_240417 - [Digital Twin with Deep Koopman neural network with K-MPC] 
  
  // 1
  // (3) 주행 성공. 수렴속도가 느림
  // epoch: 80, loss: 0.12354 (epoch 80일 때)
  // a_d << 0.05642883,  0.00039449, -0.10355321, 
  //       0.07207021, -0.04131889, -0.03448949,
  //       -0.03962682, -0.02517628,  0.13181946;

  // b_d << 0.05859251,
  //         0.22420502,
  //         0.09869999;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << -0.00172 * delta_r, -0.06012652 * delta_r, -0.04477931 * delta_r;
  
  // 2 
  // (3) 직선 주행. 이탈
  // epoch: 60, loss: 1.05089 (epoch 60일때)
  // a_d << 0.13778296, -0.00414619, -0.18936604, 
  //       0.19690949, -0.00561049, -0.26760364,
  //       0.07984547, -0.00148863, -0.10847957;

  // b_d << -0.01083519,
  //       -0.00217164,
  //       -0.01568457;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.03441361 * delta_r, 0.01342021  * delta_r, 0.03208169 * delta_r;
 
  // (4) 주행 성공 240426
  // epoch: 70, loss: 0.13186 (epoch 70일때)
  // a_d << 0.05642883,  0.00039449, -0.10355321, 
  //       0.07207021, -0.04131889, -0.03448949,
  //       -0.03962682, -0.02517628,  0.13181946;

  // b_d << 0.05859251,
  //       0.22420502,
  //       0.09869999;

  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << -0.00172 * delta_r, -0.06012652 * delta_r, -0.04477931 * delta_r;
    
  // 3 
  // (1) // 우측 이탈
  // epoch: 8, loss: 1.00667 (loss value가 1일때 A, B, Fw matrix)
  // Trained Weight : 
  // [[ 0.09691222  0.29465863 -0.15046768 -0.23058772  0.17838849]
  //  [-0.15144189 -0.40078664  0.31472555  0.14072123 -0.2040469 ]
  //  [-0.29755393 -0.21341512  0.07431363 -0.08045483 -0.4037834 ]]
  // A matrix : 
  // [[ 0.09691222  0.29465863 -0.15046768]
  //  [-0.15144189 -0.40078664  0.31472555]
  //  [-0.29755393 -0.21341512  0.07431363]]
  // B matrix : 
  // [-0.23058772  0.14072123 -0.08045483]
  // Fw matrix : 
  // [ 0.17838849 -0.2040469  -0.4037834 ]
  // a_d << 0.09691222,  0.29465863, -0.15046768, 
  //       -0.15144189, -0.40078664, 0.31472555,
  //       -0.29755393, -0.21341512, 0.07431363;

  // b_d << -0.23058772,
  //         0.14072123,
  //        -0.08045483;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.17838849 * delta_r, -0.2040469 * delta_r, -0.4037834 * delta_r;
  
  // (2) 좌측 이탈
  // epoch: 77, loss: 0.11498 (loss value가 0.1일때 A, B, Fw matrix)
  // Trained Weight : 
  // [[ 0.07563683  0.20334367 -0.16770843  0.07391248  0.4539722 ]
  //  [-0.04175061 -0.27494317  0.27491674 -0.10054776 -0.7208102 ]
  //  [-0.20434347 -0.17665546  0.03565983 -0.14317077 -0.3248033 ]]
  // A matrix : 
  // [[ 0.07563683  0.20334367 -0.16770843]
  //  [-0.04175061 -0.27494317  0.27491674]ㄴ
  //  [-0.20434347 -0.17665546  0.03565983]]
  // B matrix : 
  // [ 0.07391248 -0.10054776 -0.14317077]
  // Fw matrix : 
  // [ 0.4539722 -0.7208102 -0.3248033]
  // a_d << 0.07563683, 0.20334367, -0.16770843, 
  //       -0.04175061, -0.27494317, 0.27491674,
  //       -0.20434347, -0.17665546, 0.03565983;

  // b_d << 0.07391248,
  //         -0.10054776,
  //        -0.14317077;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.4539722 * delta_r, -0.7208102 * delta_r, -0.3248033 * delta_r;
  
  // (3) 좌측 이탈
  // epoch: 96, loss: 0.01923 (loss value가 최저의 값을 나타낼때 A, B, Fw matrix)
  // Trained Weight : 
  // [[ 0.04684173  0.16145773 -0.14217265  0.08936644  0.48513252]
  // [ 0.00880499 -0.19435425  0.22358075 -0.0447362  -0.6934555 ]
  // [-0.1742275  -0.13887894  0.01574035 -0.15544192 -0.31090957]]
  // A matrix : 
  // [[ 0.04684173  0.16145773 -0.14217265]
  // [ 0.00880499 -0.19435425  0.22358075]
  // [-0.1742275  -0.13887894  0.01574035]]
  // B matrix : 
  // [ 0.08936644 -0.0447362  -0.15544192]
  // Fw matrix : 
  // [ 0.48513252 -0.6934555  -0.31090957]
  // a_d << 0.04684173, 0.16145773, -0.14217265, 
  //       0.00880499, -0.19435425, 0.22358075,
  //       -0.1742275, -0.13887894, 0.01574035;

  // b_d << 0.08936644,
  //         -0.0447362,
  //        -0.15544192,
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.48513252 * delta_r, -0.6934555 * delta_r, -0.31090957 * delta_r;

  // 4
  // (1) 우측 이탈
  // epoch: 131, loss: 0.03373
  // Trained Weight : 
  // [[ 0.1516563  -0.02803033  0.08628085 -0.10950162  0.1489363 ]
  //  [ 0.05422263 -0.01591971  0.02955701  0.06252805 -0.02632146]
  //  [-0.15456745  0.07583393 -0.0800897  -0.14371772 -0.01951676]]
  // A matrix : 
  // [[ 0.1516563  -0.02803033  0.08628085]
  //  [ 0.05422263 -0.01591971  0.02955701]
  //  [-0.15456745  0.07583393 -0.0800897 ]]
  // B matrix : 
  // [-0.10950162  0.06252805 -0.14371772]
  // Fw matrix : 
  // [ 0.1489363  -0.02632146 -0.01951676]
  // a_d << 0.1516563, -0.02803033, 0.08628085, 
  //       0.05422263, -0.01591971, 0.02955701,
  //       -0.15456745, 0.07583393, -0.0800897;

  // b_d << -0.10950162,
  //         0.06252805,
  //         -0.14371772;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.1489363 * delta_r, -0.02632146 * delta_r, -0.01951676 * delta_r;

  // (2) 살짝 돌지만 충돌
  // epoch: 117, loss: 0.10527
  // Trained Weight : 
  // [[ 0.16412778 -0.00806842  0.09750284 -0.11021919  0.14378354]
  //  [ 0.06134417 -0.03092407  0.03147446  0.09754406 -0.03096109]
  //  [-0.16279264  0.11279297 -0.07819444 -0.12774089  0.01429337]]
  // A matrix : 
  // [[ 0.16412778 -0.00806842  0.09750284]
  //  [ 0.06134417 -0.03092407  0.03147446]
  //  [-0.16279264  0.11279297 -0.07819444]]
  // B matrix : 
  // [-0.11021919  0.09754406 -0.12774089]
  // Fw matrix : 
  // [ 0.14378354 -0.03096109  0.01429337]
  // a_d << 0.16412778, -0.00806842, 0.09750284, 
  //       0.06134417, -0.03092407, 0.03147446,
  //       -0.16279264, 0.11279297, -0.07819444;

  // b_d << -0.11021919,
  //         0.09754406,
  //         -0.12774089;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d <<  0.14378354 * delta_r, -0.03096109 * delta_r, 0.01429337 * delta_r;

  // (3) 우측 이탈
  // epoch: 113, loss: 0.48904
  // Trained Weight : 
  // [[ 0.16451742 -0.00328871  0.10337381 -0.12652487  0.11188092]
  //  [ 0.06187215 -0.03929923  0.03181915  0.09130666 -0.04496592]
  //  [-0.16291195  0.12262869 -0.08018097 -0.1193941   0.03447475]]
  // A matrix : 
  // [[ 0.16451742 -0.00328871  0.10337381]
  //  [ 0.06187215 -0.03929923  0.03181915]
  //  [-0.16291195  0.12262869 -0.08018097]]
  // B matrix : 
  // [-0.12652487  0.09130666 -0.1193941 ]
  // Fw matrix : 
  // [ 0.11188092 -0.04496592  0.03447475]
  // a_d << 0.16451742, -0.00328871, 0.10337381, 
  //       0.06187215, -0.03929923, 0.03181915,
  //       -0.16291195,  0.12262869, -0.08018097;

  // b_d << -0.12652487,
  //         0.09130666,
  //         -0.1193941;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d <<  0.11188092 * delta_r, -0.04496592 * delta_r, 0.03447475 * delta_r;

  // (4) 우측 이탈
  // epoch: 97, loss: 1.08961
  // Trained Weight : 
  // [[ 0.1677606   0.02998829  0.11391566 -0.13440582  0.09582526]
  // [ 0.06352457 -0.08349103  0.02600542  0.06560057 -0.06105263]
  // [-0.166023    0.15635756 -0.07834224 -0.14344825  0.08793331]]
  // A matrix : 
  // [[ 0.1677606   0.02998829  0.11391566]
  // [ 0.06352457 -0.08349103  0.02600542]
  // [-0.166023    0.15635756 -0.07834224]]
  // B matrix : 
  // [-0.13440582  0.06560057 -0.14344825]
  // Fw matrix : 
  // [ 0.09582526 -0.06105263  0.08793331]
  // a_d << 0.1677606, 0.02998829, 0.11391566, 
  //       0.06352457, -0.08349103, 0.02600542,
  //       -0.166023, 0.15635756, -0.07834224;

  // b_d << -0.13440582,
  //         0.06560057,
  //         -0.14344825;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d <<  0.09582526 * delta_r, -0.06105263 * delta_r, 0.08793331 * delta_r;


  // (5)
  // epoch: 86, loss: 2.00344
  // Trained Weight : 
  // [[ 0.16836902  0.06340099  0.11978025 -0.1559444   0.11328511]
  // [ 0.06349251 -0.12551823  0.01816923  0.06248881 -0.05806122]
  // [-0.1667767   0.17661083 -0.07487721 -0.15244274  0.11920666]]
  // A matrix : 
  // [[ 0.16836902  0.06340099  0.11978025]
  // [ 0.06349251 -0.12551823  0.01816923]
  // [-0.1667767   0.17661083 -0.07487721]]
  // B matrix : 
  // [-0.1559444   0.06248881 -0.15244274]
  // Fw matrix : 
  // [ 0.11328511 -0.05806122  0.11920666]
  // a_d << 0.16836902, 0.06340099, 0.11978025, 
  //       0.06349251, -0.12551823, 0.01816923,
  //       -0.1667767, 0.17661083, -0.07487721;

  // b_d << -0.1559444,
  //         0.06248881,
  //         -0.15244274;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d <<  0.11328511 * delta_r, -0.05806122 * delta_r, 0.11920666 * delta_r;

  // (6) 벽 뚫고 나감
  // epoch: 54, loss: 1.77449
  // Trained Weight : 
  // [[ 0.16927375  0.1461648   0.13457634 -0.2795906   0.09803956]
  // [ 0.06250675 -0.2588036  -0.00623951 -0.01568792  0.04053561]
  // [-0.16651419  0.21995378 -0.067546   -0.26138806  0.13443588]]
  // A matrix : 
  // [[ 0.16927375  0.1461648   0.13457634]
  // [ 0.06250675 -0.2588036  -0.00623951]
  // [-0.16651419  0.21995378 -0.067546  ]]
  // B matrix : 
  // [-0.2795906  -0.01568792 -0.26138806]
  // Fw matrix : 
  // [0.09803956 0.04053561 0.13443588]
  // a_d << 0.16927375, 0.1461648,  0.13457634, 
  //       0.06250675, -0.2588036, -0.00623951,
  //       -0.16651419, 0.21995378, -0.067546;

  // b_d << -0.2795906,
  //         -0.01568792,
  //         -0.26138806;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d <<  0.09803956 * delta_r, 0.04053561 * delta_r, 0.13443588 * delta_r;

  // a_d << 1.5653577e-04, 2.0713735e-02, 4.1362006e-02, 
  //       6.0836505e-03, 4.8070852e-02, 7.7566378e-02,
  //       2.5535265e-02, 1.7916217e-01, 3.0022725e-01;

  // b_d << 0.02457665,
  //       -0.0950192,
  //       -0.08174565;
        
  // c_d << 1.0, 0.0, 0.0, 0.0, 1.0, 0.0;

  // w_d << 0.01738206, -0.00143929, -0.05120335;


  // bilinear discretization for ZOH system
  // no discretization is needed for Cd
  Eigen::MatrixXd I = Eigen::MatrixXd::Identity(m_dim_x, m_dim_x);
  const Eigen::MatrixXd i_dt2a_inv = (I - dt * 0.5 * a_d).inverse();
  a_d = i_dt2a_inv * (I + dt * 0.5 * a_d);
  b_d = i_dt2a_inv * b_d * dt;
  w_d = i_dt2a_inv * w_d * dt;
}

void KinematicsBicycleModel::calculateReferenceInput(Eigen::MatrixXd & u_ref)
{
  u_ref(0, 0) = std::atan(m_wheelbase * m_curvature);
}
}  // namespace trajectory_follower
}  // namespace control
}  // namespace motion
}  // namespace autoware
